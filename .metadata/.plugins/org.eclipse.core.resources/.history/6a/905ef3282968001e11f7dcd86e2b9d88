Rules of Big O
 
Rule number 1: Worst Case

const nemo = ['nemo', 'test', 'two', 'three', 'four'];

function findNemo(array) {
  for (let i = 0; i < array.length; i++) {
    console.log('running');
    if (array[i] == 'nemo') {
      console.log('Found Nemo');
      break;
    }
  }
}
findNemo(nemo);

even if we have found the nemo and break the loop but what will happen if it will be in the last?
	our loop will execute until we find nemo.
	
best case can be if we have nemo at the beginning and worst case will be if we have nemo at the end.

----------------------

Rule 2: Remove constants. DSA_Class_6_1.java
we never use the numbers in our big O notations but in few cases we can use it.

we dont case how steap our graph is just we have to see if its a diagonal straight line then it is linear.

function printFirstItemThenFirstHalfThenSayHi100Times(items){
  console.log(items[0]);
  var middleIndex = Math.floor(items.length/2);
  var index = 0;
  while(index < middleIndex){
    console.log(items[index]);
    index++;
  }
  for(var i = 0; i < 100; i++){
    console.log('hi');
  }
}
// Big O(1 + n/2 + 100)
// Big O(n/2 + 101)
// Big O(n + 1)
// Big O(n)

Rule 3 Different terms for input. Most important.

function compressBoxesTwice(boxes){
  boxes.forEach(function (boxes) {
    console.log(boxes);    
  });
  
  boxes.forEach(function (boxes) {
    console.log(boxes);    
  });
}
// O(2n) -> O(n)

what will happen if we have another box as boxes2 and second loop loopes over the second.
